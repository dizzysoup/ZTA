
import express from "express";
import { server } from "@passwordless-id/webauthn";
import Fido2 from "../utils/fido2.js";
import config from "../utils/config.js";
import crypto from 'crypto';
import dotenv from 'dotenv' ; 
dotenv.config();
import db from "../db/db.js";
import base64 from "@hexagon/base64"
import username from "../utils/username.js";
const f2l = new Fido2();
import database from "../db/db.js";
import sqlite3 from 'sqlite3'
import {toBase64 , replaceSpecialChars } from "../component/component.js" 

f2l.init(config.rpId, config.rpName, undefined, config.challengeTimeoutMs);
var router = express.Router();

function base64urlEncode(data) {
	let base64 = data.toString('base64');
	base64 = base64.replace(/=/g, '');
	base64 = base64.replace(/\+/g, '-');
	base64 = base64.replace(/\//g, '_');
	return base64;
}
router.get('/' , async function(req,res){
	res.send("WebAuth is work ");
})
// 回傳challenge 
router.get('/challenge' , async function(req , res ){
	process.env.CHALLENGE = "" ;
	const challenge = crypto.randomBytes(32);
	const base64urlChallenge = base64urlEncode(challenge);
	//const base64urlChallenge  = "YTlTcHtb7VYWguhTwuk5o-8slDjvmwcRWjBRC9xgm-4"
	process.env.CHALLENGE = base64urlChallenge ; 

	return res.send(base64urlChallenge);
})

/* 註冊 */
router.post('/register', async function(req, res) {
	const expected = {
		challenge : process.env.CHALLENGE ,
		origin : "https://frontend.ztaenv.duckdns.org"
	}
	const con = await db;
	console.log("start gegisters")
	//console.table(rows);
	const registration = req.body ; 
	const registrationParsed = await server.verifyRegistration(registration, expected)	
	const id = registrationParsed.credential.id ; 
	console.log(registrationParsed.credential);
	const publicKey = registrationParsed.credential.publicKey;
	const algorithm = registrationParsed.credential.algorithm;
	const username = registrationParsed.username;
	const chk = await con.query("select *from user where username = (?)" , username);
	console.log(chk.length);
	if(chk.length == 0 ){
		await con.query("INSERT INTO user values(?,?)" , [username,id]);
		await con.query('INSERT INTO  credentials(id, publicKey,algo) values(?,?,?);', [id,publicKey,algorithm]);
		const rows = await con.query("select *from credentials");
		res.send(registrationParsed);

	}else {
		res.send("帳號已註冊");
	}
});

// 取得Id 
router.post('/Id' , async function(req , res ){
	const con = await db ; 
	const username = req.body.username ; 
	console.log(username);
	const Id = await con.query("select id from user where username = (?)" , [username]);
	console.log(Id);
	if(Id.length == 0 ){
		res.send("查無此帳號");
	}else 
		res.send(Id);
});

// 登入
router.post("/login", async (req, res) => {
	const authentication = req.body ; 
	const credentialId = authentication.credentialId ; 
	const con = await db;
	const credentials = await con.query("select *from credentials");
	
	console.log(credentialId);
	const rows = await con.query("select *from credentials where id = (?)",credentialId);	
	if(rows == null){
		res.send("empty");
	}
	const username = await con.query("select username from user where id = (?)" , credentialId);
	// 憑證從資料庫中撈
	const credentialKey  = {
		id : rows[0].id ,
		publicKey : rows[0].publicKey , 
		algorithm : rows[0].algo
	}
	
	
	// 其他設置
	const expected = {
		challenge: process.env.CHALLENGE, // whatever was randomly generated by the server.
		origin: "https://frontend.ztaenv.duckdns.org",
		userVerified: true, // should be set if `userVerification` was set to `required` in the authentication options (default)
		counter: 10 // Optional. 對於裝置綁定的憑證，您應該驗證自上次以來增加的身份驗證器「使用」計數器。
	}
	// 進行身分驗證
	const authenticationParsed = await server.verifyAuthentication(authentication, credentialKey, expected)
	
	console.log(authenticationParsed);
	// 產生JWT Token 
	if(authenticationParsed !== undefined){
		// 原本是FIDO 2 Server 產生JWT Token，現在改成向Keycloak 要 ID Token 

		const myHeaders = new Headers();
		myHeaders.append("Content-Type", "application/x-www-form-urlencoded");
		const urlencoded = new URLSearchParams();
		urlencoded.append("grant_type", "password"); // 找 keycloak fido 2 Authorization Code 方法
		urlencoded.append("client_id", "FIDOServer");
		urlencoded.append("username", "user");
		urlencoded.append("password", "user"); // 找 keycloak fido 2 授權方法
		urlencoded.append("client_secret", process.env.CLIENT_SECRET);
		urlencoded.append("scope", "openid");

		const requestOptions = {
			method: "POST",
			headers: myHeaders,
			body: urlencoded,
			redirect: "follow"
		};

		fetch("https://kong.ztaenv.duckdns.org//keycloak/realms/react-keycloak/protocol/openid-connect/token", requestOptions)
  			.then((response) => response.json())
  			.then((result) => res.send(result))
  			.catch((error) => console.error(error));
	}
	// 方法 2 : 自產生 JWT Token 
		/*
		// 產生Header 
		const header = {
			alg: 'HS256',
			typ: 'JWT',
  		};

		const b64Header = toBase64 (header);
		const jwtB64Header = replaceSpecialChars(b64Header);
		console.log ("the header is: ",jwtB64Header); 

		// 產生Payload 
		const payload = {
			iss: 'FIDO Server',// 簽發者			
			iat : Math.floor(Date.now() / 1000), // 簽發時間
			exp : Math.floor(Date.now() / 1000) + 180, // 過期時間(3分鐘)
			sub : username , // jwt所面向的用戶
			aud : 'RP' , // jwt 驗證方
			id : rows[0].id,
			isHuman: true,
		};

		const b64Payload = toBase64 (payload);
		const jwtB64Payload = replaceSpecialChars (b64Payload);
		console.log ("the payload is: ",jwtB64Payload);
		
		// 簽名
		const createSignature =(jwtB64Header,jwtB64Payload,secret)=>{
				// create a HMAC(hash based message authentication code) using sha256 hashing alg
				let signature = crypto.createHmac ('sha256', secret);
				// use the update method to hash a string formed from our jwtB64Header a period and 
				//jwtB64Payload 
				signature.update (jwtB64Header + '.' + jwtB64Payload);
				//signature needs to be converted to base64 to make it usable
				signature = signature.digest ('base64');			
				//of course we need to clean the base64 string of URL special characters
				signature = replaceSpecialChars (signature);
				return signature
			}
			// create your secret to sign the token
			const secret = rows[0].publicKey;
			const signature= createSignature(jwtB64Header,jwtB64Payload,secret);
			console.log ("the signature is: ",signature);
			const jsonWebToken = jwtB64Header + '.' + jwtB64Payload + '.' + signature;
			console.log ("the JWT is :",jsonWebToken);
			res.json({jsonWebToken});
		}
		
	else 	
		res.json({"error" : "驗證失敗"});
	*/
});

// 登出
router.post("/logout", async (req, res) => {
	console.log(req.body.refresh_token);
	const refresh_token = req.body.refresh_token;

	const myHeaders = new Headers();
	myHeaders.append("Content-Type", "application/x-www-form-urlencoded");
	const urlencoded = new URLSearchParams();
	urlencoded.append("client_id", "FIDOServer");
	urlencoded.append("client_secret", process.env.CLIENT_SECRET);
	urlencoded.append("refresh_token", refresh_token);
	//console.log(refresh_token)
	const requestOptions = {
		method: "POST",
		headers: myHeaders,
		body: urlencoded,
		redirect: "follow"
	};

	fetch("https://kong.ztaenv.duckdns.org/keycloak/realms/react-keycloak/protocol/openid-connect/logout", requestOptions)
  		.then((response) => response.text())
  		.then((result) => 
			{console.log("登出成功");res.send("登出成功");})
  		.catch((error) => {console.error(error); res.send("登出失敗")});

	
});

// Introspect
router.post("/introspect", async (req, res) => {
	const token = req.body.token;
	const myHeaders = new Headers();
	myHeaders.append("Content-Type", "application/x-www-form-urlencoded");
	const urlencoded = new URLSearchParams();
	urlencoded.append("token", token);
	urlencoded.append("client_id", "FIDOServer");
	urlencoded.append("client_secret", process.env.CLIENT_SECRET);

	const requestOptions = {
		method: "POST",
		headers: myHeaders,
		body: urlencoded,
		redirect: "follow"
	};

	fetch("https://kong.ztaenv.duckdns.org/keycloak/realms/react-keycloak/protocol/openid-connect/token/introspect", requestOptions)
  		.then((response) => response.json())
  		.then((result) => res.send(result["active"]))
  		.catch((error) => console.error(error));
});

export default router ;

