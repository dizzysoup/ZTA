
import express from "express";
import { server } from "@passwordless-id/webauthn";
import Fido2 from "../utils/fido2.js";
import config from "../utils/config.js";
import crypto from 'crypto';
import dotenv from 'dotenv' ; 
dotenv.config();
import db from "../db/db.js";
import base64 from "@hexagon/base64"
import username from "../utils/username.js";
const f2l = new Fido2();
import database from "../db/db.js";
import sqlite3 from 'sqlite3'
import {toBase64 , replaceSpecialChars } from "../component/component.js" 

f2l.init(config.rpId, config.rpName, undefined, config.challengeTimeoutMs);
var router = express.Router();

function base64urlEncode(data) {
	let base64 = data.toString('base64');
	base64 = base64.replace(/=/g, '');
	base64 = base64.replace(/\+/g, '-');
	base64 = base64.replace(/\//g, '_');
	return base64;
}

router.get('/' , async function(req,res){
	res.send("WebAuth is work ");
})

// 回傳challenge 
router.get('/challenge' , async function(req , res ){
	const challenge = crypto.randomBytes(32);
	const base64urlChallenge = base64urlEncode(challenge);
	//const base64urlChallenge  = "YTlTcHtb7VYWguhTwuk5o-8slDjvmwcRWjBRC9xgm-4"
	process.env.CHALLENGE = base64urlChallenge ; 

	return res.send(base64urlChallenge);
})

/* 註冊 */
router.post('/register', async function(req, res) {
	const expected = {
		challenge : process.env.CHALLENGE ,
		origin : "https://frontend.ztasecurity.duckdns.org"
	}
	const con = await db;
	
	//console.table(rows);
	const registration = req.body ; 
	const registrationParsed = await server.verifyRegistration(registration, expected)	
	const id = registrationParsed.credential.id ; 
	const publicKey = registrationParsed.credential.publicKey;
	const algorithm = registrationParsed.credential.algorithm;
	const username = registrationParsed.username;
	const chk = await con.query("select *from user where username = (?)" , username);
	console.log(chk.length);
	if(chk.length == 0 ){
		await con.query("INSERT INTO user values(?,?)" , [username,id]);
		await con.query('INSERT INTO  credentials(id, publicKey,algorithm) values(?,?,?);', [id,publicKey,algorithm]);
		const rows = await con.query("select *from credentials");
		console.table(rows);
		res.send(registrationParsed);
	}else {
		res.send("帳號已註冊");
	}
});

// 取得Id 
router.post('/Id' , async function(req , res ){
	const con = await db ; 
	const username = req.body.username ; 
	console.log(username);
	const Id = await con.query("select id from user where username = (?)" , [username]);
	console.log(Id);
	if(Id.length == 0 ){
		res.send("查無此帳號");
	}else 
		res.send(Id);
});

// 登入
router.post("/login", async (req, res) => {
	const authentication = req.body ; 
	const credentialId = authentication.credentialId ; 
	
	const con = await db;
	const rows = await con.query("select *from credentials where id = (?)",credentialId);	
	if(rows == null){
		res.send("empty");
	}
	const username = await con.query("select username from user where id = (?)" , credentialId);

	// 憑證從資料庫中撈
	const credentialKey  = {
		id : rows[0].id ,
		publicKey : rows[0].publicKey , 
		algorithm : rows[0].algorithm
	}
	
	
	// 其他設置
	const expected = {
		challenge: process.env.CHALLENGE, // whatever was randomly generated by the server.
		origin: "https://frontend.ztasecurity.duckdns.org",
		userVerified: true, // should be set if `userVerification` was set to `required` in the authentication options (default)
		counter: 123 // Optional. For device-bound credentials, you should verify the authenticator "usage" counter increased since last time.
	}
	// 進行身分驗證
	const authenticationParsed = await server.verifyAuthentication(authentication, credentialKey, expected)
	// 產生JWT Token 
	if(authenticationParsed !== undefined){

		// 產生Header 
		const header = {
			alg: 'HS256',
			typ: 'JWT',
  		};

		const b64Header = toBase64 (header);
		const jwtB64Header = replaceSpecialChars(b64Header);
		console.log ("the header is: ",jwtB64Header); 

		// 產生Payload 
		const payload = {
			iss: 'FIDO Server',//information about the server that issued the token
			exp: 872990,// tokens expiry date in milliseconds
			// information about some random user
			name: username ,
			id : rows[0].id,
			isHuman: true,
		};

		const b64Payload = toBase64 (payload);
		const jwtB64Payload = replaceSpecialChars (b64Payload);
		console.log ("the payload is: ",jwtB64Payload);
		
		// 簽名
		const createSignature =(jwtB64Header,jwtB64Payload,secret)=>{
			// create a HMAC(hash based message authentication code) using sha256 hashing alg
				let signature = crypto.createHmac ('sha256', secret);
			
			// use the update method to hash a string formed from our jwtB64Header a period and 
			//jwtB64Payload 
				signature.update (jwtB64Header + '.' + jwtB64Payload);
			
			//signature needs to be converted to base64 to make it usable
				signature = signature.digest ('base64');
			
			//of course we need to clean the base64 string of URL special characters
				signature = replaceSpecialChars (signature);
				return signature
			}
			// create your secret to sign the token
			const secret = rows[0].publicKey;
			const signature= createSignature(jwtB64Header,jwtB64Payload,secret);
			console.log ("the signature is: ",signature);
			const jsonWebToken = jwtB64Header + '.' + jwtB64Payload + '.' + signature;
			console.log ("the JWT is :",jsonWebToken);
			res.json({jsonWebToken});
		}
	else 	
		res.json({"error" : "驗證失敗"});
		
	/*
	if(!ctx.body || !ctx.body.username) {
		return ctx.body = {
			"status": "failed",
			"message": "ctx missing username field!"
		};
	}

	let usernameClean = username.clean(ctx.body.username);
	
	let db = database.getData("/");
	console.log(db);
	//if(!database.users[usernameClean] || !database.users[usernameClean].registered) {
	if(!db.users ||  !db.users[usernameClean] || !db.users[usernameClean].registered) {
		return ctx.body = {
			"status": "failed",
			"message": `User ${usernameClean} does not exist!`
		};
	}

	let assertionOptions = await f2l.login(usernameClean);
  console.log(assertionOptions);
	// Transfer challenge and username to session
	ctx.session.challenge = assertionOptions.challenge;
	ctx.session.username  = usernameClean;

	// Pass this, to limit selectable credentials for user... This may be set in response instead, so that
	// all of a users server (public) credentials isn't exposed to anyone
	let allowCredentials = [];
	//for(let authr of database.users[ctx.session.username].authenticators) {
	for(let authr of database.getData("/users/" + ctx.session.username + "/authenticators")) {
		allowCredentials.push({
			type: authr.type,
			id: base64.fromArrayBuffer(authr.credId, true),
			transports: authr.transports
		});
	}

	assertionOptions.allowCredentials = allowCredentials;

	ctx.session.allowCredentials = allowCredentials;
	*/
	//return ctx.body = assertionOptions;
});

// 內省
router.post("/introspect" , async function(req , res){

})

// 授權
router.post("/token" , async function(req , res){

})

export default router ;
//module.exports = router;
